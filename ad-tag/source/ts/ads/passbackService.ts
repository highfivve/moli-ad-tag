import { MoliRuntime } from '../types/moliRuntime';
import { googletag } from '../types/googletag';

/**
 * @internal
 */
type IPassbackMessage = {
  type: 'passback';

  /**
   * the domId of the ad slot that should be refreshed.
   *
   * This is used as a fallback if the `adUnitPath` is not set.
   * The `adUnitPath` should be prefered as it is more generic
   * and can be auto-generated by GAM.
   */
  domId?: string;

  /**
   * the adUnitPath of the ad slot that should be refreshed.
   *
   * If set the adUnitPath will be used to search of the ad slot
   * and the DOM ID is being ignored.
   */
  adUnitPath?: string;

  /**
   * name of the advertisier who is the origin for the passback to being triggered
   */
  passbackOrigin: string;
};

/**
 * @internal
 */
export class PassbackService {
  /**
   * We lazy initialize the window message listener and track
   * the state with this flag.
   *
   * Initialization starts when the first adSlot is added.
   */
  private isInitialized: boolean = false;

  /**
   * AdSlots that have passback support enabled
   */
  private readonly adSlots: {
    [domIdOrAdUnitPath: string]: MoliRuntime.SlotDefinition;
  } = {};

  private readonly passbackKeyValue: string = 'passback';
  private readonly passbackOriginKeyValue: string = 'passbackOrigin';

  constructor(
    private readonly logger: MoliRuntime.MoliLogger,
    private readonly window: Window & googletag.IGoogleTagWindow
  ) {}

  addAdSlot(adSlot: MoliRuntime.SlotDefinition): void {
    // initialize on the first add call
    if (!this.isInitialized) {
      this.isInitialized = true;
      this.initMessageListener();
    }

    this.adSlots[adSlot.moliSlot.domId] = adSlot;
    this.adSlots[adSlot.moliSlot.adUnitPath] = adSlot;
  }

  private initMessageListener(): void {
    this.logger.debug('Passback Service', 'Add message listener');
    this.window.addEventListener('message', (event: MessageEvent) => {
      // avoid infinite loops by not allowing to send message to one self
      const message = this.parseMessageData(event.data);
      if (!message) {
        return;
      }

      this.logger.debug('Passback Service', 'Received passback message', message);

      const adSlot = this.findAdSlot(message);
      if (adSlot) {
        this.logger.debug('Passback Service', 'Process passback for ad slot');
        adSlot.adSlot.setTargeting(this.passbackKeyValue, 'true');
        adSlot.adSlot.setTargeting(this.passbackOriginKeyValue, message.passbackOrigin);

        // previously we had changeCorrelator: true (see GD-1615), but this hadn't the intended effect
        // so we removed it (see GD-1696)
        this.window.googletag.pubads().refresh([adSlot.adSlot]);

        // allow passback only once
        delete this.adSlots[adSlot.moliSlot.domId];
        delete this.adSlots[adSlot.moliSlot.adUnitPath];
      }
    });
  }

  private parseMessageData(data: any): IPassbackMessage | null {
    if (typeof data === 'string') {
      try {
        const message = JSON.parse(data);
        if (
          message.type === 'passback' &&
          message.passbackOrigin &&
          (message.domId || message.adUnitPath)
        ) {
          return message;
        }
        // if this is not a valid message we return null
        return null;
      } catch (err) {
        // invalid json - another iframe message was posted
        return null;
      }
    }
    // only handle string data
    return null;
  }

  private findAdSlot = (message: IPassbackMessage): MoliRuntime.SlotDefinition | undefined => {
    if (message.adUnitPath) {
      return this.adSlots[message.adUnitPath];
    } else if (message.domId) {
      return this.adSlots[message.domId];
    } else {
      return;
    }
  };
}
