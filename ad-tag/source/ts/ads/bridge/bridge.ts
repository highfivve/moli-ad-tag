import { googletag } from 'ad-tag/types/googletag';
import { AdPipelineContext, InitStep, mkInitStep } from 'ad-tag/ads/adPipeline';
import { isPlainObject } from 'ad-tag/util/objectUtils';

export type PassbackMessage = {
  /**
   */
  event: 'h5.adunit.passback';

  /**
   * the domId of the ad slot that should be refreshed.
   *
   * This is used as a fallback if the `adUnitPath` is not set.
   * The `adUnitPath` should be prefered as it is more generic
   * and can be auto-generated by GAM.
   */
  domId?: string;

  /**
   * the adUnitPath of the ad slot that should be refreshed.
   *
   * If set the adUnitPath will be used to search of the ad slot
   * and the DOM ID is being ignored.
   */
  adUnitPath?: string;

  /**
   * name of the advertisier who is the origin for the passback to being triggered
   */
  passbackOrigin: string;
};

export type RefreshAdUnitMessage = {
  event: 'h5.adunit.refresh';
  domId: string;
};

export type BridgeProtocol = PassbackMessage | RefreshAdUnitMessage;

const findAdSlot = (
  message: { domId?: string; adUnitPath?: string },
  googletag: googletag.IGoogleTag
): googletag.IAdSlot | undefined =>
  googletag
    .pubads()
    .getSlots()
    .find(
      slot =>
        slot.getSlotElementId() === message.domId || slot.getAdUnitPath() === message.adUnitPath
    );

const parseMessageData = (data: any): BridgeProtocol | null => {
  try {
    const message: BridgeProtocol | null =
      typeof data === 'string' ? JSON.parse(data) : isPlainObject(data) ? data : null;

    switch (message?.event) {
      case 'h5.adunit.passback':
        return message.passbackOrigin && (message.domId || message.adUnitPath) ? message : null;
      case 'h5.adunit.refresh':
        return message;
      default:
        // if this is not a valid message we return null
        return null;
    }
  } catch (err) {
    // invalid json - another iframe message was posted
    return null;
  }
};

/**
 * Refresh message are sent by third party creatives to indicate that they have no ads to show.
 * Calls the backfill ad slot to refresh the ad slot.
 *
 * @param message post message data
 * @param context
 */
const handleRefresh = (message: RefreshAdUnitMessage, context: AdPipelineContext): void => {
  const backfillMoliSlot = context.config.slots.find(
    slot => slot.domId === message.domId && slot.behaviour.loaded === 'backfill'
  );
  const adSlot = findAdSlot(message, context.window.googletag);
  if (backfillMoliSlot && adSlot) {
    context.logger.debug('bridge', `Refresh ad slot ${message.domId}`);
    context.window.googletag.destroySlots([adSlot]);
    context.window.moli
      .refreshAdSlot(message.domId, { loaded: 'backfill' })
      .catch(e => context.logger.error('bridge', `failed to refresh ${message.domId}`, e));
  }
};

/**
 * Passback message are sent by third party creatives to indicate that they don't have any ads to show.
 *
 * The ad slot will be refreshed if a window.postMessage event is being sent from
 * a creative identifying the ad slot by domId or ad unit path. In additional key value `passback:true` will
 * be set indicating this is a passback request. The rest of the key-values will be untouched
 * keeping the prebid / a9 auction key-values.
 *
 *
 * ## Example creative snippet
 *
 * This is an example of how a passback function could look like in a creative.
 * Note that you can either use the `adUnitPath` or the `domId` of the slot.
 *
 * `adUnitPath` is not yet fully supported, when using variables in the ad unit path.
 *
 * ```
 * var passbackCallback = function() {
 *   var request = JSON.stringify({
 *     type: 'passback',
 *     adUnitPath: '%%ADUNIT%%' ,
 *     passbackOrigin: '[ADVERTISER-NAME]'
 *   });
 *   try {
 *     // first try to post a message on the top most window
 *     window.top.postMessage(request, '*');
 *   } catch (_) {
 *     // best-effort postMessage
 *     window.postMessage(request, '*');
 *   }
 * }
 * ```
 *
 * Default is `false`
 *
 * @param message
 * @param context
 */
const handlePassback = (message: PassbackMessage, context: AdPipelineContext): void => {
  const adSlot = findAdSlot(message, context.window.googletag);
  const passbackKey = 'passback';
  // only refresh if the ad slot is available and has not yet been marked as passback
  if (adSlot && adSlot.getTargeting(passbackKey).length === 0) {
    context.logger.debug('passback', `Process passback for ad slot ${adSlot.getAdUnitPath()}`);
    adSlot.setTargeting(passbackKey, 'true');
    adSlot.setTargeting('passbackOrigin', message.passbackOrigin);

    // previously we had changeCorrelator: true (see GD-1615), but this hadn't the intended effect
    // so we removed it (see GD-1696)
    context.window.googletag.pubads().refresh([adSlot]);
  }
};

export const bridgeInitStep = (): InitStep =>
  mkInitStep('bridge', (context: AdPipelineContext) => {
    if (context.config.bridge?.enabled) {
      context.logger.debug('bridge', 'add message listener');
      context.window.addEventListener('message', (event: MessageEvent<BridgeProtocol>) => {
        const message = parseMessageData(event.data);
        if (message) {
          switch (message.event) {
            case 'h5.adunit.passback':
              handlePassback(message, context);
              break;
            case 'h5.adunit.refresh':
              handleRefresh(message, context);
              break;
          }
        }
      });
    }
    return Promise.resolve();
  });
